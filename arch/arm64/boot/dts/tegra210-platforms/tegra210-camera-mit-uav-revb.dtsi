/*
 * Copyright (c) 2015-2016, NVIDIA CORPORATION.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <dt-bindings/media/camera.h>
#include <dt-bindings/platform/t210/t210.h>

#define GANG_MODE_L_R 1
#define GANG_MODE_T_B 2
#define GANG_MODE_R_L 3
#define GANG_MODE_B_T 4

#define CAM0_RST_L  TEGRA_GPIO(S, 7)
#define CAM1_RST_L  TEGRA_GPIO(T, 0)
#define CAM2_RST_L  TEGRA_GPIO(S, 4)

#define CAM_MUX0    TEGRA_GPIO(T, 1)
#define CAM_MUX1    TEGRA_GPIO(S, 6)

/*
#define CAM0_RST_L  TEGRA_GPIO(E, 5)

#define CAM_MUX0    TEGRA_GPIO(T, 1)
#define CAM_MUX1    TEGRA_GPIO(S, 6)
*/



//GPIOs
/ {
  /* set camera gpio direction to output */
  gpio: gpio@6000d000 {
    camera-control {
      gpio-output-low = <
                        CAM0_RST_L
                        CAM1_RST_L
                        CAM2_RST_L
                        CAM_MUX0
                        CAM_MUX1
                        >;
    };
  };
};


/ {
  host1x {
    vi_base: vi {
      num-channels = <1>;
      ports {
        #address-cells = <1>;
        #size-cells = <0>;
        vi_port0: port@0 {
          status = "okay";
          reg = <0>;
          ov5647_vi_in0: endpoint {
            status = "okay";
            csi-port = <0>;
            bus-width = <2>;
            remote-endpoint = <&ov5647_out0>;
          };
        };
      };
    };

//XXX: Experimental!
    i2c_cam_mux {
      status = "okay";
      compatable="i2c-mux-gpio";
      mux-gpios=<&gpio CAM_MUX0 &gpio CAM_MUX1>;
      //i2c-parent=<i2c@546c0000>
      i2c-parent=<&i2c7>;
      #address-cells = <1>;
      #size-cells = <0>;


      i2c@0 {
        reg = <0>;
        status = "okay";
        #address-cells = <1>;
        #size-cells = <0>;
        ov5647_a@36 {
          compatible = "nvidia,ov5647";
          // I2C device address
          reg = <0x36>;
          reset-gpios = <&gpio CAM0_RST_L GPIO_ACTIVE_LOW>;
 
          // Physical dimensions of sensor
          physical_w = "3.674";
          physical_h = "2.738";
 
 
          // Sensor Mode
          sensor_model ="ov5647";
 
          //Define any required hw resources needed by driver
          //ie. clocks, io pins, power sources
          //avdd-reg = "vana";
          //iovdd-reg = "vif";
          //dvdd-reg = "vdig";
          clocks = <&tegra_car TEGRA210_CLK_ID_CLK_OUT_3>;
          clock-names = "mclk";
          clock-frequency = <24000000>;
          mclk = "cam_mclk1";
 
          // Defines number of frames to be dropped by driver internally after applying
          // sensor crop settings. Some sensors send corrupt frames after applying
          // crop co-ordinates
          post_crop_frame_drop = "0";
 
          mode0 { // OV5647_MODE_1920X1080
            mclk_khz = "24000";
            num_lanes = "2";
            //mclk_multiplier = "49.0";
            //My Stuff
            //pix_clk_hz = "1176000000";
            //pix_clk_hz   =  "588000000";
            //line_length = "2416";
 
            //Their Stuff
            mclk_multiplier = "17.0";
            pix_clk_hz = "160000000";
            line_length = "2688";
            //Done
 
            tegra_sinterface = "serial_a";
            discontinuous_clk = "yes";
            cil_settletime = "0";
            pixel_t = "bayer_bggr";
            readout_orientation = "0";
            inherent_gain = "1";
 
            //active_w = "2322";
            //active_h = "1104";
            active_w = "1920";
            active_h = "1080";
 
            //line_length = "1927";
 
            min_gain_val = "1.0";
            max_gain_val = "16.0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            min_framerate = "1";
            max_framerate = "30";
            min_exp_time = "25";
            max_exp_time = "683709";
          };
          mode1 { // OV5647_MODE_1280X720
            mclk_khz = "24000";
            num_lanes = "2";
            mclk_multiplier = "52.5";
            pix_clk_hz = "1260000000";
 
            tegra_sinterface = "serial_a";
            discontinuous_clk = "yes";
            cil_settletime = "0";
            pixel_t = "bayer_bggr";
            readout_orientation = "0";
            inherent_gain = "1";
 
            active_w = "1280";
            active_h = "720";
 
            //line_length = "2623";
            line_length = "1896";
 
            min_gain_val = "1.0";
            max_gain_val = "16.0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            min_framerate = "1";
            max_framerate = "60";
            min_exp_time = "22";
            max_exp_time = "683709";
 
          };
 
          ports {
            #address-cells = <1>;
            #size-cells = <0>;
 
            port@0 {
              reg = <0>;
              ov5647_out0: endpoint {
                csi-port = <0>;
                bus-width = <2>;
                remote-endpoint = <&ov5647_vi_in0>;
              };
            };
          };
        };
      };
      i2c@1 {
        reg = <1>;
      };
      i2c@2 {
        reg = <2>;
      };
    };
//XXX: Experimental!

//XXX: Known Good!

/*
    i2c@546c0000 {
      status = "okay";
      #address-cells = <1>;
      #size-cells = <0>;
      ov5647_a@36 {
        compatible = "nvidia,ov5647";
        // I2C device address
        reg = <0x36>;
        reset-gpios = <&gpio CAM0_RST_L GPIO_ACTIVE_LOW>;

        // Physical dimensions of sensor
        physical_w = "3.674";
        physical_h = "2.738";


        // Sensor Mode
        sensor_model ="ov5647";

        //Define any required hw resources needed by driver
        //ie. clocks, io pins, power sources
        //avdd-reg = "vana";
        //iovdd-reg = "vif";
        //dvdd-reg = "vdig";
        clocks = <&tegra_car TEGRA210_CLK_ID_CLK_OUT_3>;
        clock-names = "mclk";
        clock-frequency = <24000000>;
        mclk = "cam_mclk1";

        // Defines number of frames to be dropped by driver internally after applying
        // sensor crop settings. Some sensors send corrupt frames after applying
        // crop co-ordinates
        post_crop_frame_drop = "0";

        mode0 { // OV5647_MODE_1920X1080
          mclk_khz = "24000";
          num_lanes = "2";
          //mclk_multiplier = "49.0";
          //My Stuff
          //pix_clk_hz = "1176000000";
          //pix_clk_hz   =  "588000000";
          //line_length = "2416";

          //Their Stuff
          mclk_multiplier = "17.0";
          pix_clk_hz = "160000000";
          line_length = "2688";
          //Done

          tegra_sinterface = "serial_a";
          discontinuous_clk = "yes";
          cil_settletime = "0";
          pixel_t = "bayer_bggr";
          readout_orientation = "0";
          inherent_gain = "1";

          //active_w = "2322";
          //active_h = "1104";
          active_w = "1920";
          active_h = "1080";

          //line_length = "1927";

          min_gain_val = "1.0";
          max_gain_val = "16.0";
          min_hdr_ratio = "1";
          max_hdr_ratio = "1";
          min_framerate = "1";
          max_framerate = "30";
          min_exp_time = "25";
          max_exp_time = "683709";
        };
        mode1 { // OV5647_MODE_1280X720
          mclk_khz = "24000";
          num_lanes = "2";
          mclk_multiplier = "52.5";
          pix_clk_hz = "1260000000";

          tegra_sinterface = "serial_a";
          discontinuous_clk = "yes";
          cil_settletime = "0";
          pixel_t = "bayer_bggr";
          readout_orientation = "0";
          inherent_gain = "1";

          active_w = "1280";
          active_h = "720";

          //line_length = "2623";
          line_length = "1896";

          min_gain_val = "1.0";
          max_gain_val = "16.0";
          min_hdr_ratio = "1";
          max_hdr_ratio = "1";
          min_framerate = "1";
          max_framerate = "60";
          min_exp_time = "22";
          max_exp_time = "683709";

        };

        ports {
          #address-cells = <1>;
          #size-cells = <0>;

          port@0 {
            reg = <0>;
            ov5647_out0: endpoint {
              csi-port = <0>;
              bus-width = <2>;
              remote-endpoint = <&ov5647_vi_in0>;
            };
          };
        };
      };
    };
*/
//XXX: Known Good!
  };

  tegra-camera-platform {
    compatible = "nvidia, tegra-camera-platform";

    /**
    * The general guideline for naming badge_info contains 3 parts, and is as follows,
    * The first part is the camera_board_id for the module; if the module is in a FFD
    * platform, then use the platform name for this part.
    * The second part contains the position of the module, ex. “rear” or “front”.
    * The third part contains the last 6 characters of a part number which is found
    * in the module's specsheet from the vender.
    */
    modules {
      cam_module0: module0 {
        badge = "uav_back_ov5647";
        position = "rear";
        orientation = "1";
        cam_module0_drivernode0: drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
          pcl_id = "v4l2_sensor";
          /* Driver's v4l2 device name */
          devname = "ov5647 6-0036";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/ov5647_a@36";
          status = "okay";
        };
        cam_module0_dirvernode1: drivernode1 {
          status = "disabled";
          pcl_id = "v4l2_focuser_stub";
          proc-device-tree = "";

        };
      };
    };
  };
};
